{
	"Macro": {
		"prefix": "mac",
		"body": [
			"from collections import deque, defaultdict, Counter",
			"from bisect import bisect_left, bisect_right",
			"from atcoder.fenwicktree import FenwickTree",
			"from atcoder.segtree import SegTree",
			"from atcoder.lazysegtree import LazySegTree",
			"from atcoder.dsu import DSU",
			"from atcoder.scc import SCCGraph",
			"from atcoder.string import suffix_array",
			"from itertools import permutations, combinations",
			"from functools import cmp_to_key, cache",
			"from more_itertools import distinct_permutations",
			"from heapq import heappop, heappush",
			"import math, sys",
			"import pypyjit",
			"pypyjit.set_param('max_unroll_recursion=-1')",
			"sys.setrecursionlimit(10**7)",
			"_int = lambda x: int(x)-1",
			"MOD = 998244353",
			"INF = 1<<62",
			"Yes, No = \"Yes\", \"No\"",
			"",
			"$0"
		]
	},
	"pypy saiki": {
		"prefix": "saiki",
		"body": [
			"import pypyjit",
			"pypyjit.set_param('max_unroll_recursion=-1')"
		]
	},
	"int input": {
		"prefix": "intinput",
		"body": [
			"int(input())"
		]
	},
	"map input": {
		"prefix": "mapinput",
		"body": [
			"map(int, input().split())"
		]
	},
	"list map input": {
		"prefix": "listmapinput",
		"body": [
			"list(map(int, input().split()))"
		]
	},
	"tuple map input": {
		"prefix": "tuplemapinput",
		"body": [
			"tuple(map(int, input().split()))"
		]
	},
	"dir4": {
		"prefix": "dir4",
		"body": [
			"dir = [(0, 1), (1, 0), (0, -1), (-1, 0)]"
		]
	}, 
	"dir8": {
		"prefix": "dir8",
		"body": [
			"dir = [(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)]"
		]
	},
	"dirstr": {
		"prefix": "dirstr",
		"body": [
			"dir = {\"U\":(1, 0), \"D\":(-1, 0), \"R\":(0, 1), \"L\":(0, -1)}"
		]
	},
	"Sorted set": {
		"prefix": "sortedset",
		"body": [
			"from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional",
			"T = TypeVar('T')",
			"",
			"class SortedSet(Generic[T]):",
			"    BUCKET_RATIO = 16",
			"    SPLIT_RATIO = 24",
			"",
			"    def __init__(self, a: Iterable[T] = []) -> None:",
			"        a = list(a)",
			"        n = self.size = len(a)",
			"        if any(a[i] > a[i + 1] for i in range(n - 1)):",
			"            a.sort()",
			"        if any(a[i] >= a[i + 1] for i in range(n - 1)):",
			"            a, b = [], a",
			"            for x in b:",
			"                if not a or a[-1] != x:",
			"                    a.append(x)",
			"        bucket_size = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
			"        self.a = [a[n * i // bucket_size : n * (i + 1) // bucket_size] for i in range(bucket_size)]",
			"",
			"    def __iter__(self) -> Iterator[T]:",
			"        for i in self.a:",
			"            for j in i: yield j",
			"",
			"    def __reversed__(self) -> Iterator[T]:",
			"        for i in reversed(self.a):",
			"            for j in reversed(i): yield j",
			"",
			"    def __eq__(self, other) -> bool:",
			"        return list(self) == list(other)",
			"",
			"    def __len__(self) -> int:",
			"        return self.size",
			"",
			"    def __repr__(self) -> str:",
			"        return \"SortedSet\" + str(self.a)",
			"",
			"    def __str__(self) -> str:",
			"        s = str(list(self))",
			"        return \"{\" + s[1 : len(s) - 1] + \"}\"",
			"",
			"    def _position(self, x: T) -> Tuple[List[T], int, int]:",
			"        for i, a in enumerate(self.a):",
			"            if x <= a[-1]: break",
			"        return (a, i, bisect_left(a, x))",
			"",
			"    def __contains__(self, x: T) -> bool:",
			"        if self.size == 0: return False",
			"        a, _, i = self._position(x)",
			"        return i != len(a) and a[i] == x",
			"",
			"    def add(self, x: T) -> bool:",
			"        if self.size == 0:",
			"            self.a = [[x]]",
			"            self.size = 1",
			"            return True",
			"        a, b, i = self._position(x)",
			"        if i != len(a) and a[i] == x: return False",
			"        a.insert(i, x)",
			"        self.size += 1",
			"        if len(a) > len(self.a) * self.SPLIT_RATIO:",
			"            mid = len(a) >> 1",
			"            self.a[b:b+1] = [a[:mid], a[mid:]]",
			"        return True",
			"",
			"    def _pop(self, a: List[T], b: int, i: int) -> T:",
			"        ans = a.pop(i)",
			"        self.size -= 1",
			"        if not a: del self.a[b]",
			"        return ans",
			"",
			"    def discard(self, x: T) -> bool:",
			"        if self.size == 0: return False",
			"        a, b, i = self._position(x)",
			"        if i == len(a) or a[i] != x: return False",
			"        self._pop(a, b, i)",
			"        return True",
			"",
			"    def lt(self, x: T) -> Optional[T]:",
			"        for a in reversed(self.a):",
			"            if a[0] < x:",
			"                return a[bisect_left(a, x) - 1]",
			"",
			"    def le(self, x: T) -> Optional[T]:",
			"        for a in reversed(self.a):",
			"            if a[0] <= x:",
			"                return a[bisect_right(a, x) - 1]",
			"",
			"    def gt(self, x: T) -> Optional[T]:",
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return a[bisect_right(a, x)]",
			"",
			"    def ge(self, x: T) -> Optional[T]:",
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return a[bisect_left(a, x)]",
			"",
			"    def __getitem__(self, i: int) -> T:",
			"        if i < 0:",
			"            for a in reversed(self.a):",
			"                i += len(a)",
			"                if i >= 0: return a[i]",
			"        else:",
			"            for a in self.a:",
			"                if i < len(a): return a[i]",
			"                i -= len(a)",
			"        raise IndexError",
			"",
			"    def pop(self, i: int = -1) -> T:",
			"        if i < 0:",
			"            for b, a in enumerate(reversed(self.a)):",
			"                i += len(a)",
			"                if i >= 0: return self._pop(a, ~b, i)",
			"        else:",
			"            for b, a in enumerate(self.a):",
			"                if i < len(a): return self._pop(a, b, i)",
			"                i -= len(a)",
			"        raise IndexError",
			"",
			"    def index(self, x: T) -> int:",
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return ans + bisect_left(a, x)",
			"            ans += len(a)",
			"        return ans",
			"",
			"    def index_right(self, x: T) -> int:",
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return ans + bisect_right(a, x)",
			"            ans += len(a)",
			"        return ans"
		]
	},
	"Sorted multi set":{
		"prefix": "sortedmultiset",
		"body": [
			"from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional",
			"T = TypeVar('T')",
			"",
			"class SortedMultiSet(Generic[T]):",
			"    BUCKET_RATIO = 16",
			"    SPLIT_RATIO = 24",
			"",
			"    def __init__(self, a: Iterable[T] = []) -> None:",
			"        a = list(a)",
			"        n = self.size = len(a)",
			"        if any(a[i] > a[i + 1] for i in range(n - 1)):",
			"            a.sort()",
			"        bucket_size = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
			"        self.a = [a[n * i // bucket_size : n * (i + 1) // bucket_size] for i in range(bucket_size)]",	
			"",
			"    def __iter__(self) -> Iterator[T]:",
			"        for i in self.a:",
			"            for j in i: yield j",
			"",
			"    def __reversed__(self) -> Iterator[T]:",
			"        for i in reversed(self.a):",
			"            for j in reversed(i): yield j",
			"",
			"    def __eq__(self, other) -> bool:",
			"        return list(self) == list(other)",
			"",
			"    def __len__(self) -> int:",
			"        return self.size",
			"",
			"    def __repr__(self) -> str:",
			"        return \"SortedMultiset\" + str(self.a)",
			"",
			"    def __str__(self) -> str:",
			"        s = str(list(self))",
			"        return \"{\" + s[1 : len(s) - 1] + \"}\"",
			"",
			"    def _position(self, x: T) -> Tuple[List[T], int, int]:",
			"        for i, a in enumerate(self.a):",
			"            if x <= a[-1]: break",
			"        return (a, i, bisect_left(a, x))",
			"",
			"    def __contains__(self, x: T) -> bool:",
			"        if self.size == 0: return False",
			"        a, _, i = self._position(x)",
			"        return i != len(a) and a[i] == x",
			"",
			"    def count(self, x: T) -> int:",
			"        return self.index_right(x) - self.index(x)",
			"",
			"    def add(self, x: T) -> None:",
			"        if self.size == 0:",
			"            self.a = [[x]]",
			"            self.size = 1",
			"            return",
			"        a, b, i = self._position(x)",
			"        a.insert(i, x)",
			"        self.size += 1",
			"        if len(a) > len(self.a) * self.SPLIT_RATIO:",
			"            mid = len(a) >> 1",
			"            self.a[b:b+1] = [a[:mid], a[mid:]]",
			"",
			"    def _pop(self, a: List[T], b: int, i: int) -> T:",
			"        ans = a.pop(i)",
			"        self.size -= 1",
			"        if not a: del self.a[b]",
			"        return ans",
			"",
			"    def discard(self, x: T) -> bool:",
			"        if self.size == 0: return False",
			"        a, b, i = self._position(x)",
			"        if i == len(a) or a[i] != x: return False",
			"        self._pop(a, b, i)",
			"        return True",
			"",
			"    def lt(self, x: T) -> Optional[T]:",
			"        for a in reversed(self.a):",
			"            if a[0] < x:",
			"                return a[bisect_left(a, x) - 1]",
			"",
			"    def le(self, x: T) -> Optional[T]:",
			"        for a in reversed(self.a):",
			"            if a[0] <= x:",
			"                return a[bisect_right(a, x) - 1]",
			"",
			"    def gt(self, x: T) -> Optional[T]:",
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return a[bisect_right(a, x)]",
			"",
			"    def ge(self, x: T) -> Optional[T]:",
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return a[bisect_left(a, x)]",
			"",
			"    def __getitem__(self, i: int) -> T:",
			"        if i < 0:",
			"            for a in reversed(self.a):",
			"                i += len(a)",
			"                if i >= 0: return a[i]",
			"        else:",
			"            for a in self.a:",
			"                if i < len(a): return a[i]",
			"                i -= len(a)",
			"        raise IndexError",
			"",
			"    def pop(self, i: int = -1) -> T:",
			"        if i < 0:",
			"            for b, a in enumerate(reversed(self.a)):",
			"                i += len(a)",
			"                if i >= 0: return self._pop(a, ~b, i)",
			"        else:",
			"            for b, a in enumerate(self.a):",
			"                if i < len(a): return self._pop(a, b, i)",
			"                i -= len(a)",
			"        raise IndexError",
			"",
			"    def index(self, x: T) -> int:",
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return ans + bisect_left(a, x)",
			"            ans += len(a)",
			"        return ans",
			"",
			"    def index_right(self, x: T) -> int:",
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return ans + bisect_right(a, x)",
			"            ans += len(a)",
			"        return ans"
		]
	},
	"factor": {
		"prefix": "factor",
		"body": [
			"FACMAX = $1",
			"FAC = [0]*(FACMAX+1)",
			"FAC[1] = 1",
			"for i in range(2, FACMAX+1, 2):",
			"    FAC[i] = 2",
			"for f in range(3, FACMAX+1, 2):",
			"    if FAC[f] != 0: continue",
			"    for i in range(f, FACMAX+1, f):",
			"        if FAC[i] == 0: FAC[i] = f",
			"",
			"def factor(num):",
			"    num = int(num)",
			"    ret = []",
			"    while num != 1:",
			"        f = FAC[num]",
			"        cnt = 0",
			"        while num%f == 0:",
			"            cnt += 1",
			"            num //= f",
			"        ret.append((f, cnt))",
			"    return ret",
			"",
			"$0"
		]
	},
	"factor_big": {
		"prefix": "factor_big",
		"body": [
			"def factor(X):",
			"    M = X",
			"    ret = []",
			"    if X == 1: return []",
			"    if X%2 == 0:",
			"        cnt = 0",
			"        while X%2 == 0:",
			"            X //= 2",
			"            cnt += 1",
			"        ret.append((2, cnt))",
			"    for x in range(3, math.isqrt(M)+1, 2):",
			"        if X%x == 0:",
			"            cnt = 0",
			"            while X%x == 0:",
			"                X //= x",
			"                cnt += 1",
			"            ret.append((x, cnt))",
			"    if X != 1: ret.append((X, 1))",
			"    return ret"
		]
	},
	"prime": {
		"prefix": "prime",
		"body": [
			"def prime(num):",
			"    num = int(num)",
			"    p = []",
			"    if num < 2: return p",
			"    p.append(2)",
			"    memo = [i%2 for i in range(num+1)]",
			"    for i in range(3, num+1, 2):",
			"        if memo[i] == 0: continue",
			"        p.append(i)",
			"        for j in range(i, num+1, i):",
			"            memo[j] = 0",
			"    return p"
		]
	},
	"divisor": {
		"prefix": "divisor",
		"body": [
			"def div(num):",
			"    ret = []",
			"    i = 1",
			"    while i*i <= num:",
			"        if num%i == 0:",
			"            ret.append(i)",
			"            if i*i < num: ret.append(num//i)",
			"        i += 1",
			"    ret.sort()",
			"    return ret"
		]
	},
	"comb": {
		"prefix": "comb",
		"body": [
			"NMAX = 1000",
			"F = [1]*(NMAX+1)",
			"for i in range(2, NMAX+1):",
			"    F[i] = F[i-1]*i%MOD",
			"RF = [1]*NMAX + [pow(F[NMAX], -1, MOD)]",
			"for i in reversed(range(2, NMAX+1)):",
			"    RF[i-1] = RF[i]*i%MOD",
			"def comb(n, r):",
			"    return F[n]*RF[r]*RF[n-r]%MOD"
		]
	}
}