{
	"Macro": {
		"prefix": "mac",
		"body": [
			"from collections import deque, defaultdict, Counter",
			"from bisect import bisect_left, bisect_right",
			"from atcoder.fenwicktree import FenwickTree",
			"from atcoder.segtree import SegTree",
			"from atcoder.lazysegtree import LazySegTree",
			"from atcoder.string import suffix_array, z_algorithm",
			"from itertools import permutations, combinations",
			"from functools import cache",
			"from heapq import heappop, heappush",
			"import math, sys",
			"input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")",
			"_int = lambda x: int(x)-1",
			"MOD = 998244353 #10**9+7",
			"INF = 1<<60",
			"Yes, No = \"Yes\", \"No\"",
			"",
			"$0"
		]
	},	
	"YukicoderMacro": {
		"prefix": "ymac",
		"body": [
			"from collections import deque, defaultdict, Counter",
			"from bisect import bisect_left, bisect_right",
			"from itertools import permutations, combinations",
			"from heapq import heappop, heappush",
			"import math, sys",
			"# input = sys.stdin.readline",
			"_int = lambda x: int(x)-1",
			"MOD = 998244353 #10**9+7",
			"INF = 1<<60",
			"Yes, No = \"Yes\", \"No\"",
			"",
			"$0"
		]
	},
	"Interactive macro": {
		"prefix": "macro_interactive",
		"body": [
			"import sys",
			"debug = False # 変更不可",
			"",
			"if sys.argv[-1] == \"MY_JUDGE\":",
			"    debug = True",
			"",
			"# テスト環境用の変数宣言。",
			"N = 1729",
			"",
			"def input_prod_values():",
			"    # TODO: 本番環境の変数入力を書く。",
			"    global N",
			"    N = int(input())",
			"",
			"from random import *",
			"def randomize_test_values():",
			"    # TODO: テスト環境の変数をランダムに決める。",
			"    global N",
			"    N = randint(1, 100)",
			"",
			"def print_test_values():",
			"    # TODO: テスト環境の変数出力を書く。",
			"    print(N)",
			"",
			"def ask(): # TODO: 引数を任意に決める。",
			"    res = None",
			"    if debug:",
			"        # TODO: テスト環境の変数を元に聞かれている質問に答える処理を書く。",
			"        res = 0",
			"    else:",
			"        # TODO: ジャッジに聞く処理を書く。",
			"        res = 0",
			"    return res",
			"",
			"def solve():",
			"    ans = None",
			"    # TODO: 問題を解く処理を書く。ジャッジに聞くときはask()を使う。",
			"    return ans",
			"",
			"def check(ans):",
			"    # TODO: 答えをテスト環境の変数と比べて正誤判定をする。正解ならTrue。",
			"    return True",
			"",
			"if debug:",
			"    T = 1000",
			"    for _ in range(T):",
			"        randomize_test_values()",
			"        ans = solve()",
			"        if check(ans): continue",
			"        print_test_values()",
			"        break",
			"    else:",
			"        print(\"Test passed.\")",
			"else:",
			"    input_prod_values()",
			"    ans = solve()",
			"    # TODO: 本番環境の答え出力の処理を書く。"

		]
	},
	"pypy saiki": {
		"prefix": "saiki",
		"body": [
			"import pypyjit, sys",
			"pypyjit.set_param('max_unroll_recursion=-1')",
			"sys.setrecursionlimit(10**6)"
		]
	},
	"int input": {
		"prefix": "intinput",
		"body": [
			"int(input())"
		]
	},
	"map input": {
		"prefix": "mapinput",
		"body": [
			"map(int, input().split())"
		]
	},
	"list map input": {
		"prefix": "listmapinput",
		"body": [
			"list(map(int, input().split()))"
		]
	},
	"tuple map input": {
		"prefix": "tuplemapinput",
		"body": [
			"tuple(map(int, input().split()))"
		]
	},
	"local code": {
		"prefix": ["localcode", "myjudge"],
		"body": [
			"if sys.argv[-1] == \"MY_JUDGE\":",
			"    $0"
		]
	},
	"Horizontal line": {
		"prefix": ["sen", "kugiri", "line"],
		"body": "print(\"--------------\")"
	},
	"dir4": {
		"prefix": "dir4",
		"body": [
			"dir = [(0, 1), (1, 0), (0, -1), (-1, 0)]"
		]
	}, 
	"dir8": {
		"prefix": "dir8",
		"body": [
			"dir = [(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)]"
		]
	},
	"dirstr": {
		"prefix": "dirstr",
		"body": [
			"dir = {\"U\":(1, 0), \"D\":(-1, 0), \"R\":(0, 1), \"L\":(0, -1)}"
		]
	},
	"posng": {
		"prefix": "posng",
		"body": [
			"if ni < 0 or H <= ni or nj < 0 or W <= nj: continue"
		]
	},
	"chmax": {
		"prefix": "chmax",
		"body": [
			"$1 = max($1, $2)$0"
		]
	},
	"chmin": {
		"prefix": "chmin",
		"body": [
			"$1 = min($1, $2)$0"
		]
	},
	"chmodsum": {
		"prefix": "chmod",
		"body": [
			"$1 = ($1 + $2)%MOD"
		]
	},
	"Sorted set": {
		"prefix": "sortedset",
		"body": [
			"# https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py",
			"import math",
			"from bisect import bisect_left, bisect_right",
			"from typing import Generic, Iterable, Iterator, TypeVar",
			"Type = TypeVar('Type')",
			"",
			"class SortedSet(Generic[Type]):",
			"    BUCKET_RATIO = 16",
			"    SPLIT_RATIO = 24",
			"    ",
			"    def __init__(self, a: Iterable[Type] = []) -> None:",
			"        # Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)",
			"        a = list(a)",
			"        n = len(a)",
			"        if any(a[i] > a[i + 1] for i in range(n - 1)):",
			"            a.sort()",
			"        if any(a[i] >= a[i + 1] for i in range(n - 1)):",
			"            a, b = [], a",
			"            for x in b:",
			"                if not a or a[-1] != x:",
			"                    a.append(x)",
			"        n = self.size = len(a)",
			"        num_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
			"        self.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
			"",
			"    def __iter__(self) -> Iterator[Type]:",
			"        for i in self.a:",
			"            for j in i: yield j",
			"",
			"    def __reversed__(self) -> Iterator[Type]:",
			"        for i in reversed(self.a):",
			"            for j in reversed(i): yield j",
			"    ",
			"    def __eq__(self, other) -> bool:",
			"        return list(self) == list(other)",
			"    ",
			"    def __len__(self) -> int:",
			"        return self.size",
			"    ",
			"    def __repr__(self) -> str:",
			"        return 'SortedSet' + str(self.a)",
			"    ",
			"    def __str__(self) -> str:",
			"        s = str(list(self))",
			"        return '{' + s[1 : len(s) - 1] + '}'",
			"",
			"    def _position(self, x: Type) -> tuple[list[Type], int, int]:",
			"        # return the bucket, index of the bucket and position in which x should be. self must not be empty.",
			"        for i, a in enumerate(self.a):",
			"            if x <= a[-1]: break",
			"        return (a, i, bisect_left(a, x))",
			"",
			"    def __contains__(self, x: Type) -> bool:",
			"        if self.size == 0: return False",
			"        a, _, i = self._position(x)",
			"        return i != len(a) and a[i] == x",
			"",
			"    def add(self, x: Type) -> bool:",
			"        # Add an element and return True if added. / O(√N)",
			"        if self.size == 0:",
			"            self.a = [[x]]",
			"            self.size = 1",
			"            return True",
			"        a, b, i = self._position(x)",
			"        if i != len(a) and a[i] == x: return False",
			"        a.insert(i, x)",
			"        self.size += 1",
			"        if len(a) > len(self.a) * self.SPLIT_RATIO:",
			"            mid = len(a) >> 1",
			"            self.a[b:b+1] = [a[:mid], a[mid:]]",
			"        return True",
			"    ",
			"    def _pop(self, a: list[Type], b: int, i: int) -> Type:",
			"        ans = a.pop(i)",
			"        self.size -= 1",
			"        if not a: del self.a[b]",
			"        return ans",
			"",
			"    def discard(self, x: Type) -> bool:",
			"        # Remove an element and return True if removed. / O(√N)",
			"        if self.size == 0: return False",
			"        a, b, i = self._position(x)",
			"        if i == len(a) or a[i] != x: return False",
			"        self._pop(a, b, i)",
			"        return True",
			"    ",
			"    def lt(self, x: Type) -> Type | None:",
			"        # Find the largest element < x, or None if it doesn't exist.",
			"        for a in reversed(self.a):",
			"            if a[0] < x:",
			"                return a[bisect_left(a, x) - 1]",
			"",
			"    def le(self, x: Type) -> Type | None:",
			"        # Find the largest element <= x, or None if it doesn't exist.",
			"        for a in reversed(self.a):",
			"            if a[0] <= x:",
			"                return a[bisect_right(a, x) - 1]",
			"",
			"    def gt(self, x: Type) -> Type | None:",
			"        # Find the smallest element > x, or None if it doesn't exist.",
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return a[bisect_right(a, x)]",
			"",
			"    def ge(self, x: Type) -> Type | None:",
			"        # Find the smallest element >= x, or None if it doesn't exist.",
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return a[bisect_left(a, x)]",
			"    ",
			"    def __getitem__(self, i: int) -> Type:",
			"        # Return the i-th element.",
			"        if i < 0:",
			"            for a in reversed(self.a):",
			"                i += len(a)",
			"                if i >= 0: return a[i]",
			"        else:",
			"            for a in self.a:",
			"                if i < len(a): return a[i]",
			"                i -= len(a)",
			"        raise IndexError",
			"    ",
			"    def pop(self, i: int = -1) -> Type:",
			"        # Pop and return the i-th element.",
			"        if i < 0:",
			"            for b, a in enumerate(reversed(self.a)):",
			"                i += len(a)",
			"                if i >= 0: return self._pop(a, ~b, i)",
			"        else:",
			"            for b, a in enumerate(self.a):",
			"                if i < len(a): return self._pop(a, b, i)",
			"                i -= len(a)",
			"        raise IndexError",
			"    ",
			"    def index(self, x: Type) -> int:",
			"        # Count the number of elements < x.",
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return ans + bisect_left(a, x)",
			"            ans += len(a)",
			"        return ans",
			"",
			"    def index_right(self, x: Type) -> int:",
			"        # Count the number of elements <= x.",
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return ans + bisect_right(a, x)",
			"            ans += len(a)",
			"        return ans"
		]
	},
	"Sorted multi set":{
		"prefix": "sortedmultiset",
		"body": [
			"# https://github.com/tatyam-prime/SortedSet/blob/main/SortedMultiset.py",
			"import math",
			"from bisect import bisect_left, bisect_right",
			"from typing import Generic, Iterable, Iterator, TypeVar",
			"Type = TypeVar('Type')",
			"",
			"class SortedMultiset(Generic[Type]):",
			"    BUCKET_RATIO = 16",
			"    SPLIT_RATIO = 24",
			"    ",
			"    def __init__(self, a: Iterable[Type] = []) -> None:",
			"        # Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)",
			"        a = list(a)",
			"        n = self.size = len(a)",
			"        if any(a[i] > a[i + 1] for i in range(n - 1)):",
			"            a.sort()",
			"        num_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
			"        self.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
			"",
			"    def __iter__(self) -> Iterator[Type]:",
			"        for i in self.a:",
			"            for j in i: yield j",
			"",
			"    def __reversed__(self) -> Iterator[Type]:",
			"        for i in reversed(self.a):",
			"            for j in reversed(i): yield j",
			"    ",
			"    def __eq__(self, other) -> bool:",
			"        return list(self) == list(other)",
			"    ",
			"    def __len__(self) -> int:",
			"        return self.size",
			"    ",
			"    def __repr__(self) -> str:",
			"        return 'SortedMultiset' + str(self.a)",
			"    ",
			"    def __str__(self) -> str:",
			"        s = str(list(self))",
			"        return '{' + s[1 : len(s) - 1] + '}'",
			"",
			"    def _position(self, x: Type) -> tuple[list[Type], int, int]:",
			"        # return the bucket, index of the bucket and position in which x should be. self must not be empty.",
			"        for i, a in enumerate(self.a):",
			"            if x <= a[-1]: break",
			"        return (a, i, bisect_left(a, x))",
			"",
			"    def __contains__(self, x: Type) -> bool:",
			"        if self.size == 0: return False",
			"        a, _, i = self._position(x)",
			"        return i != len(a) and a[i] == x",
			"",
			"    def count(self, x: Type) -> int:",
			"        # Count the number of x.",
			"        return self.index_right(x) - self.index(x)",
			"",
			"    def add(self, x: Type) -> None:",
			"        # Add an element. / O(√N)",
			"        if self.size == 0:",
			"            self.a = [[x]]",
			"            self.size = 1",
			"            return",
			"        a, b, i = self._position(x)",
			"        a.insert(i, x)",
			"        self.size += 1",
			"        if len(a) > len(self.a) * self.SPLIT_RATIO:",
			"            mid = len(a) >> 1",
			"            self.a[b:b+1] = [a[:mid], a[mid:]]",
			"    ",
			"    def _pop(self, a: list[Type], b: int, i: int) -> Type:",
			"        ans = a.pop(i)",
			"        self.size -= 1",
			"        if not a: del self.a[b]",
			"        return ans",
			"",
			"    def discard(self, x: Type) -> bool:",
			"        # Remove an element and return True if removed. / O(√N)",
			"        if self.size == 0: return False",
			"        a, b, i = self._position(x)",
			"        if i == len(a) or a[i] != x: return False",
			"        self._pop(a, b, i)",
			"        return True",
			"",
			"    def lt(self, x: Type) -> Type | None:",
			"        # Find the largest element < x, or None if it doesn't exist.",
			"        for a in reversed(self.a):",
			"            if a[0] < x:",
			"                return a[bisect_left(a, x) - 1]",
			"",
			"    def le(self, x: Type) -> Type | None:",
			"        # Find the largest element <= x, or None if it doesn't exist.",
			"        for a in reversed(self.a):",
			"            if a[0] <= x:",
			"                return a[bisect_right(a, x) - 1]",
			"",
			"    def gt(self, x: Type) -> Type | None:",
			"        # Find the smallest element > x, or None if it doesn't exist.",
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return a[bisect_right(a, x)]",
			"",
			"    def ge(self, x: Type) -> Type | None:",
			"        # Find the smallest element >= x, or None if it doesn't exist.",
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return a[bisect_left(a, x)]",
			"    ",
			"    def __getitem__(self, i: int) -> Type:",
			"        # Return the i-th element.",
			"        if i < 0:",
			"            for a in reversed(self.a):",
			"                i += len(a)",
			"                if i >= 0: return a[i]",
			"        else:",
			"            for a in self.a:",
			"                if i < len(a): return a[i]",
			"                i -= len(a)",
			"        raise IndexError",
			"    ",
			"    def pop(self, i: int = -1) -> Type:",
			"        # Pop and return the i-th element.",
			"        if i < 0:",
			"            for b, a in enumerate(reversed(self.a)):",
			"                i += len(a)",
			"                if i >= 0: return self._pop(a, ~b, i)",
			"        else:",
			"            for b, a in enumerate(self.a):",
			"                if i < len(a): return self._pop(a, b, i)",
			"                i -= len(a)",
			"        raise IndexError",
			"",
			"    def index(self, x: Type) -> int:",
			"        # Count the number of elements < x.",
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] >= x:",
			"                return ans + bisect_left(a, x)",
			"            ans += len(a)",
			"        return ans",
			"",
			"    def index_right(self, x: Type) -> int:",
			"        # Count the number of elements <= x.",
			"        ans = 0",
			"        for a in self.a:",
			"            if a[-1] > x:",
			"                return ans + bisect_right(a, x)",
			"            ans += len(a)",
			"        return ans"
		]
	},
	"SCC":{
		"prefix": "scc",
		"body": [
			"def scc(N,edges):",
			"    M=len(edges)",
			"    start=[0]*(N+1)",
			"    elist=[0]*M",
			"    for e in edges:",
			"        start[e[0]+1]+=1",
			"    for i in range(1,N+1):",
			"        start[i]+=start[i-1]",
			"    counter=start[:]",
			"    for e in edges:",
			"        elist[counter[e[0]]]=e[1]",
			"        counter[e[0]]+=1",
			"    visited=[]",
			"    low=[0]*N",
			"    Ord=[-1]*N",
			"    ids=[0]*N",
			"    NG=[0,0]",
			"    def dfs(v):",
			"        stack=[(v,-1,0),(v,-1,1)]",
			"        while stack:",
			"            v,bef,t=stack.pop()",
			"            if t:",
			"                if bef!=-1 and Ord[v]!=-1:",
			"                    low[bef]=min(low[bef],Ord[v])",
			"                    stack.pop()",
			"                    continue",
			"                low[v]=NG[0]",
			"                Ord[v]=NG[0]",
			"                NG[0]+=1",
			"                visited.append(v)",
			"                for i in range(start[v],start[v+1]):",
			"                    to=elist[i]",
			"                    if Ord[to]==-1:",
			"                        stack.append((to,v,0))",
			"                        stack.append((to,v,1))",
			"                    else:",
			"                        low[v]=min(low[v],Ord[to])",
			"            else:",
			"                if low[v]==Ord[v]:",
			"                    while(True):",
			"                        u=visited.pop()",
			"                        Ord[u]=N",
			"                        ids[u]=NG[1]",
			"                        if u==v:",
			"                            break",
			"                    NG[1]+=1",
			"                low[bef]=min(low[bef],low[v])",
			"    for i in range(N):",
			"        if Ord[i]==-1:",
			"            dfs(i)",
			"    for i in range(N):",
			"        ids[i]=NG[1]-1-ids[i]",
			"    group_num=NG[1]",
			"    counts=[0]*group_num",
			"    for x in ids:",
			"        counts[x]+=1",
			"    groups=[[] for _ in range(group_num)]",
			"    for i in range(N):",
			"        groups[ids[i]].append(i)",
			"    return groups"
		]
	},
	"Doubling": {
		"prefix": "doubling",
		"body": [
			"# B_i <- A_x_i",
			"def f(x, p): # O(NlogP) 使いまわすなら真面目に",
			"    if p == 0:",
			"        return [i for i in range(N)]",
			"    elif p%2:",
			"        y = f(x, p-1)",
			"        return [y[v] for v in x]",
			"    else:",
			"        y = f(x, p//2)",
			"        return [y[v] for v in y]"
		]
	},
	"factor": {
		"prefix": "factor",
		"body": [
			"FACMAX = $1",
			"FAC = [0]*(FACMAX+1)",
			"FAC[1] = 1",
			"for i in range(2, FACMAX+1, 2):",
			"    FAC[i] = 2",
			"for f in range(3, FACMAX+1, 2):",
			"    if FAC[f] != 0: continue",
			"    for i in range(f, FACMAX+1, f):",
			"        if FAC[i] == 0: FAC[i] = f",
			"",
			"def factor(num):",
			"    num = int(num)",
			"    ret = []",
			"    while num != 1:",
			"        f = FAC[num]",
			"        cnt = 0",
			"        while num%f == 0:",
			"            cnt += 1",
			"            num //= f",
			"        ret.append((f, cnt))",
			"    return ret",
			"",
			"$0"
		]
	},
	"factor_big": {
		"prefix": "factor_big",
		"body": [
			"def factor(X):",
			"    M = X",
			"    ret = []",
			"    if X == 1: return []",
			"    if X%2 == 0:",
			"        cnt = 0",
			"        while X%2 == 0:",
			"            X //= 2",
			"            cnt += 1",
			"        ret.append((2, cnt))",
			"    for x in range(3, math.isqrt(M)+1, 2):",
			"        if X%x == 0:",
			"            cnt = 0",
			"            while X%x == 0:",
			"                X //= x",
			"                cnt += 1",
			"            ret.append((x, cnt))",
			"    if X != 1: ret.append((X, 1))",
			"    return ret"
		]
	},
	"prime": {
		"prefix": "prime",
		"body": [
			"def prime(num):",
			"    num = int(num)",
			"    p = []",
			"    if num < 2: return p",
			"    p.append(2)",
			"    memo = [i%2 for i in range(num+1)]",
			"    for i in range(3, num+1, 2):",
			"        if memo[i] == 0: continue",
			"        p.append(i)",
			"        for j in range(i, num+1, i):",
			"            memo[j] = 0",
			"    return p"
		]
	},
	"divisor": {
		"prefix": "divisor",
		"body": [
			"def div(num):",
			"    ret = []",
			"    i = 1",
			"    while i*i <= num:",
			"        if num%i == 0:",
			"            ret.append(i)",
			"            if i*i < num: ret.append(num//i)",
			"        i += 1",
			"    ret.sort()",
			"    return ret"
		]
	},
	"comb": {
		"prefix": "comb",
		"body": [
			"NMAX = 1000",
			"F = [1]*(NMAX+1)",
			"for i in range(2, NMAX+1):",
			"    F[i] = F[i-1]*i%MOD",
			"RF = [1]*NMAX + [pow(F[NMAX], -1, MOD)]",
			"for i in reversed(range(2, NMAX+1)):",
			"    RF[i-1] = RF[i]*i%MOD",
			"def comb(n, r):",
			"    return F[n]*RF[r]*RF[n-r]%MOD"
		]
	},
	"extgcd": {
		"prefix": ["gcdext", "extgcd"],
		"body": [
			"def extgcd(a, b) -> tuple[int, int]:",
			"    if b == 0: return 1, 0",
			"    y, x = extgcd(b, a%b)",
			"    y -= (a//b)*x",
			"    return x, y"
		]
	},
	"cmp_to_key": {
		"prefix": "cmp_to_key",
		"body": [
			"from typing import *",
			"",
			"def sort(data: List[Any]):",
			"    if len(data) == 1: return",
			"    res = _sort(data)",
			"    data.clear()",
			"    data.extend(res)",
			"",
			"def _sort(data: List[Any]):",
			"    if len(data) <= 1:",
			"        return data",
			"    m = len(data)//2",
			"    ret = merge(_sort(data[:m]), _sort(data[m:]))",
			"    return ret",
			"",
			"def merge(l, r):",
			"    res = []",
			"    i, j = 0, 0",
			"    while i < len(l) and j < len(r):",
			"        if cmp(l[i], r[j]):",
			"            res.append(l[i])",
			"            i += 1",
			"        else:",
			"            res.append(r[j])",
			"            j += 1",
			"    if i < len(l): res.extend(l[i:])",
			"    if j < len(r): res.extend(r[j:])",
			"    return res",
			"",
			"def cmp(p1, p2):",
			"    # p1が左ならTrue"
		]
	},
	"DSU": {
		"prefix": "dsu",
		"body": [
			"import typing",
			"class DSU:",
			"    def __init__(self,",
			"                 n: int,",
			"                 op: typing.Callable[[typing.Any, typing.Any], typing.Any] = lambda a, b: a+b,",
			"                 rev: typing.Callable[[typing.Any], typing.Any] = lambda a: -a,",
			"                 e: typing.Any = 0) -> None:",
			"        self._op = op",
			"        self._rev = rev",
			"        self._e = e",
			"        ",
			"        self._n = n",
			"        self._size = [1]*n",
			"        self._parent = [*range(n)]",
			"        self._weight = [self._e]*n",
			"",
			"    def _leader_and_potential(self, a: int) -> typing.Tuple[int, typing.Any]:",
			"        assert 0 <= a < self._n",
			"        potential = self._e",
			"        while self._parent[a] != a:",
			"            self._weight[a] = self._op(self._weight[a], self._weight[self._parent[a]])",
			"            self._parent[a] = self._parent[self._parent[a]]",
			"            potential = self._op(potential, self._weight[a])",
			"            a = self._parent[a]",
			"        return a, potential",
			"    ",
			"    def leader(self, a: int) -> int:",
			"        assert 0 <= a < self._n",
			"        p, _ = self._leader_and_potential(a)",
			"        return p",
			"",
			"    def merge(self, a: int, b: int, d: typing.Any = 0) -> bool:",
			"        assert 0 <= a < self._n",
			"        assert 0 <= b < self._n",
			"        x, px = self._leader_and_potential(a)",
			"        y, py = self._leader_and_potential(b)",
			"",
			"        if x == y:",
			"            return self._op(px, d) == py",
			"        ",
			"        potential = self._op(d, self._op(px, self._rev(py)))",
			"",
			"        if self._size[x] < self._size[y]:",
			"            self._weight[x] = self._rev(potential)",
			"            self._parent[x] = y",
			"            self._size[y] += self._size[x]",
			"        else:",
			"            self._weight[y] = potential",
			"            self._parent[y] = x",
			"            self._size[x] += self._size[y]",
			"        return True",
			"",
			"    def same(self, a: int, b: int) -> bool:",
			"        assert 0 <= a < self._n",
			"        assert 0 <= b < self._n",
			"        return self.leader(a) == self.leader(b)",
			"",
			"    def size(self, a: int) -> int:",
			"        assert 0 <= a < self._n",
			"        return self._size[self.leader(a)]",
			"",
			"    def potential(self, a: int, b: int) -> typing.Any:",
			"        x, px = self._leader_and_potential(a)",
			"        y, py = self._leader_and_potential(b)",
			"        if x == y:",
			"            return self._op(self._rev(px), py)",
			"        return None",
			"",
			"    def groups(self) -> typing.List[typing.List[int]]:",
			"        leader_buf = [self.leader(i) for i in range(self._n)]",
			"        result: typing.List[typing.List[int]] = [[] for _ in range(self._n)]",
			"        for i in range(self._n):",
			"            result[leader_buf[i]].append(i)",
			"        return list(filter(lambda r: r, result))"
		]
	},
	"Dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"from heapq import heappop, heappush",
			"from typing import *",
			"class Dijkstra:",
			"    INF = 1<<60",
			"    shift = 20",
			"    mask = (1<<shift)-1",
			"",
			"    def __init__(self, n: int):",
			"        self._n = n",
			"        self._E = [[] for _ in range(self._n)]",
			"    ",
			"    def _init_data(self) -> None:",
			"        self._dist = [Dijkstra.INF]*self._n",
			"        self._vis = [0]*self._n",
			"        self._bf = [-1]*self._n",
			"    ",
			"    def add_edge(self, u: int, v: int, c: int, directed: bool = False) -> None:",
			"        assert 0 <= u < self._n",
			"        assert 0 <= v < self._n",
			"        assert c >= 0",
			"        self._E[u].append(c<<Dijkstra.shift | v)",
			"        if directed: return",
			"        self._E[v].append(c<<Dijkstra.shift | u)",
			"    ",
			"    def calc(self, start: int) -> List[int]:",
			"        assert 0 <= start < self._n",
			"        self._init_data()",
			"        self._dist[start] = 0",
			"        self._last_start = start",
			"        q = [start]",
			"        while q:",
			"            ni = heappop(q)",
			"            cost, i = ni >> Dijkstra.shift, ni & Dijkstra.mask",
			"            if self._vis[i]: continue",
			"            self._vis[i] = 1",
			"            for nj in self._E[i]:",
			"                c, j = nj >> Dijkstra.shift, nj & Dijkstra.mask",
			"                tc = cost+c",
			"                if self._vis[j]: continue",
			"                if self._dist[j] <= tc: continue",
			"                self._dist[j] = tc",
			"                self._bf[j] = i",
			"                heappush(q, tc<<Dijkstra.shift | j)",
			"        return self._dist",
			"    ",
			"    def vis(self) -> List[int]:",
			"        return self._vis",
			"",
			"    def dist(self) -> List[int]:",
			"        return self._dist",
			"    ",
			"    def path_to(self, goal: int) -> Union[List[int], None]:",
			"        assert 0 <= goal < self._n",
			"        if self._vis[goal] == 0:",
			"            return None",
			"        cur = goal",
			"        ret = [cur]",
			"        while cur != self._last_start:",
			"            cur = self._bf[cur]",
			"            ret.append(cur)",
			"        ret.reverse()",
			"        return ret"
		]
	},
	"Bucket List": {
		"prefix": "bucketlist",
		"body": [
			"# https://github.com/tatyam-prime/SortedSet/blob/main/BucketList.py",
			"import math",
			"from typing import Generic, Iterable, Iterator, TypeVar",
			"T = TypeVar('T')",
			"",
			"class BucketList(Generic[T]):",
			"    BUCKET_RATIO = 16",
			"    SPLIT_RATIO = 24",
			"    ",
			"    def __init__(self, a: Iterable[T] = []) -> None:",
			"        a = list(a)",
			"        n = self.size = len(a)",
			"        num_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
			"        self.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
			"",
			"    def __iter__(self) -> Iterator[T]:",
			"        for i in self.a:",
			"            for j in i: yield j",
			"",
			"    def __reversed__(self) -> Iterator[T]:",
			"        for i in reversed(self.a):",
			"            for j in reversed(i): yield j",
			"    ",
			"    def __eq__(self, other) -> bool:",
			"        if len(self) != len(other): return False",
			"        for x, y in zip(self, other):",
			"            if x != y: return False",
			"        return True",
			"    ",
			"    def __len__(self) -> int:",
			"        return self.size",
			"    ",
			"    def __repr__(self) -> str:",
			"        return 'BucketList' + str(self.a)",
			"    ",
			"    def __str__(self) -> str:",
			"        return str(list(self))",
			"",
			"    def __contains__(self, x: T) -> bool:",
			"        for y in self:",
			"            if x == y: return True",
			"        return False",
			"    ",
			"    def _insert(self, a: list[T], b: int, i: int, x: T) -> None:",
			"        a.insert(i, x)",
			"        self.size += 1",
			"        if len(a) > len(self.a) * self.SPLIT_RATIO:",
			"            mid = len(a) >> 1",
			"            self.a[b:b+1] = [a[:mid], a[mid:]]",
			"",
			"    def insert(self, i: int, x: T) -> None:",
			"        if self.size == 0:",
			"            if i != 0 and i != -1: raise IndexError",
			"            self.a = [[x]]",
			"            self.size = 1",
			"            return",
			"        if i < 0:",
			"            for b, a in enumerate(reversed(self.a)):",
			"                i += len(a)",
			"                if i >= 0: return self._insert(a, len(self.a) + ~b, i, x)",
			"        else:",
			"            for b, a in enumerate(self.a):",
			"                if i <= len(a): return self._insert(a, b, i, x)",
			"                i -= len(a)",
			"",
			"    def append(self, x: T) -> None:",
			"        a = self.a[-1]",
			"        return self._insert(a, len(self.a) - 1, len(a), x)",
			"    ",
			"    def extend(self, a: Iterable[T]) -> None:",
			"        for x in a: self.append(x)",
			"    ",
			"    def __getitem__(self, i: int) -> T:",
			"        if i < 0:",
			"            for a in reversed(self.a):",
			"                i += len(a)",
			"                if i >= 0: return a[i]",
			"        else:",
			"            for a in self.a:",
			"                if i < len(a): return a[i]",
			"                i -= len(a)",
			"        raise IndexError",
			"    ",
			"    def _pop(self, a: list[T], b: int, i: int) -> T:",
			"        ans = a.pop(i)",
			"        self.size -= 1",
			"        if not a: del self.a[b]",
			"        return ans",
			"    ",
			"    def pop(self, i: int = -1) -> T:",
			"        if i < 0:",
			"            for b, a in enumerate(reversed(self.a)):",
			"                i += len(a)",
			"                if i >= 0: return self._pop(a, ~b, i)",
			"        else:",
			"            for b, a in enumerate(self.a):",
			"                if i < len(a): return self._pop(a, b, i)",
			"                i -= len(a)",
			"        raise IndexError",
			"",
			"    def count(self, x: T) -> int:",
			"        return sum(1 for y in self if x == y)",
			"",
			"    def index(self, x: T) -> int:",
			"        for i, y in enumerate(self):",
			"            if x == y: return i",
			"        raise ValueError",
			"    ",
			"    def remove(self, x: T) -> None:",
			"        self.pop(self.index(x))",
			"",
			"    def clear(self) -> None:",
			"        self.a = []",
			"        self.size = 0",
			"",
			"    def reverse(self) -> None:",
			"        self.a.reverse()",
			"        for a in self.a: a.reverse()",
			"",
			"    def copy(self) -> 'BucketList[T]':",
			"        return BucketList(self)"
		]
	},
	"Rolling Hash": {
		"prefix": "rollinghash",
		"body": [
			"MOD = (1<<61)-1",
			"import random",
			"rand_seed = random.randint(2, MOD-2)",
			"class RollingHash:",
			"    _MASK30 = (1<<30)-1",
			"    _MASK31 = (1<<31)-1",
			"    _MASK61 = MOD",
			"",
			"    def __init__(self, st: str, reverse: bool = False):",
			"        if reverse: st = st[::-1]",
			"        self._rev = reverse",
			"        self._st = [self._to_num(c) for c in st]",
			"        self._n = len(st)",
			"        self._li = []",
			"        self._cum = [0]",
			"        self._powr = [1]",
			"        self._rpow = [1]",
			"        self._change = False",
			"        invr = pow(rand_seed, -1, MOD)",
			"        for c in self._st:",
			"            value = self._mul(c, self._powr[-1])",
			"            self._li.append(value)",
			"            self._cum.append(self._add(self._cum[-1], value))",
			"            self._powr.append(self._mul(self._powr[-1],rand_seed))",
			"            self._rpow.append(self._mul(self._rpow[-1],invr))",
			"",
			"    @staticmethod",
			"    def _to_num(element):",
			"        return ord(element)-96",
			"",
			"    @staticmethod",
			"    def _op(a, b): ",
			"        if a+b >= MOD: return a+b-MOD",
			"        else: return a+b",
			"",
			"    # https://qiita.com/keymoon/items/11fac5627672a6d6a9f6",
			"    @staticmethod",
			"    def _mul(a, b):",
			"        au = a >> 31",
			"        ad = a & RollingHash._MASK31",
			"        bu = b >> 31",
			"        bd = b & RollingHash._MASK31",
			"        mid = ad * bu + au * bd",
			"        midu = mid >> 30",
			"        midd = mid & RollingHash._MASK30",
			"        return RollingHash._calc_mod(au * bu * 2 + midu + (midd << 31) + ad * bd)",
			"    ",
			"    @staticmethod",
			"    def _calc_mod(x):",
			"        xu = x >> 61",
			"        xd = x & RollingHash._MASK61",
			"        return RollingHash._add(xu, xd)",
			"    ",
			"    @staticmethod",
			"    def _sub(a, b):",
			"        if a >= b: return a-b",
			"        return MOD+a-b",
			"    ",
			"    @staticmethod",
			"    def _add(a, b):",
			"        ret = a+b",
			"        if ret >= MOD: return ret-MOD",
			"        return ret",
			"",
			"    def set(self, p: int, c: str):",
			"        assert 0 <= p < self._n",
			"        if self._rev: p = self._n-p-1",
			"        if self._change == False:",
			"            self._S = SegTree(self._op, 0, self._li)",
			"            self._change = True",
			"        self._S.set(p, self._sub(self._S.get(p), self._mul(self._st[p],self._powr[p])))",
			"        self._st[p] = self._to_num(c)",
			"        self._S.set(p, self._add(self._S.get(p), self._mul(self._st[p],self._powr[p])))",
			"    ",
			"    # [l, r)",
			"    def value(self, l: int, r: int):",
			"        if self._rev: l, r = self._n-r, self._n-l",
			"        if l == r == self._n: return 0",
			"        assert 0 <= l <= r <= self._n",
			"        if self._change:",
			"            ret = self._mul(self._S.prod(l, r), self._rpow[l])",
			"        else:",
			"            ret = self._mul(self._sub(self._cum[r], self._cum[l]), self._rpow[l])",
			"        return ret"
		]
	},
	"Sum of a geometric sequence": {
		"prefix": "touhi", 
		"body": [
			"def touhi_wa(fi, lst, cnt, use_last = True):",
			"    if use_last:",
			"        # 末項の場合",
			"        return (fi+lst)*cnt//2",
			"    else:",
			"        # 公差の場合",
			"        d = lst",
			"        return (2*fi+(cnt-1)*d)*cnt//2"
		]
	},
	"Flip": {
		"prefix": "flip",
		"body": [
			"def flip(G):",
			"    h, w = len(G), len(G[0])",
			"    nG = [[0]*w for _ in range(h)]",
			"    for i in range(h):",
			"        for j in range(w):",
			"            nG[i][j] = G[i][w-j-1]",
			"    return nG"
		]
	},
	"Rotate": {
		"prefix": "rotate",
		"body": [
			"def rotate(G):",
			"    # 反時計周り",
			"    h, w = len(G), len(G[0])",
			"    nG = [[0]*h for _ in range(w)]",
			"    for i in range(h):",
			"        for j in range(w):",
			"            nG[i][j] = G[j][h-i-1]",
			"    return nG"
		]
	},
	"Next Permutations": {
		"prefix": "nextpermutations",
		"body": [
			"def next_permutations(li):",
			"    n = len(li)",
			"    for i in reversed(range(1, n)):",
			"        if li[i-1] < li[i]:",
			"            ch = i-1",
			"            break",
			"    else:",
			"        return False",
			"    for i in reversed(range(ch+1, n)):",
			"        if li[i] > li[ch]:",
			"            li[i], li[ch] = li[ch], li[i]",
			"            break",
			"    for i in range(ch+1, n):",
			"        j = n-(i-ch-1)-1",
			"        if i >= j: break",
			"        li[i], li[j] = li[j], li[i]",
			"    return True"
		]
	},
	"DistList": {
		"prefix": "distlist",
		"body": [
			"def distlist(st, n, edge):",
			"    q = deque([st])",
			"    dist = [-1]*n",
			"    dist[st] = 0",
			"    while q:",
			"        i = q.popleft()",
			"        for j in edge[i]:",
			"            if dist[j] >= 0: continue",
			"            dist[j] = dist[i]+1",
			"            q.append(j)",
			"    return dist"
		]	
	},
	"Merge Sort Tree": {
		"prefix": "mergesorttree",
		"body": [
			"from bisect import bisect_right",
			"from typing import *",
			"",
			"class MergeSortTree:",
			"    @staticmethod",
			"    def _ceil_pow2(n: int) -> int:",
			"        x = 0",
			"        while (1 << x) < n:",
			"            x += 1",
			"        return x",
			"",
			"    def __init__(self, v: List[int]):",
			"        self._n = len(v)",
			"        self._log = MergeSortTree._ceil_pow2(self._n)",
			"        self._size = 1 << self._log",
			"        self._d = [list()]*(2*self._size)",
			"        self._cum = [list()]*(2*self._size)",
			"        self._d[1] = v[::]",
			"        for i in range(1, 2*self._size):",
			"            self._update_down(i)",
			"",
			"    def count_le(self, left: int, right: int, x: int) -> int:",
			"        assert 0 <= left <= right <= self._n",
			"        ret = 0",
			"        left += self._size",
			"        right += self._size",
			"",
			"        while left < right:",
			"            if left & 1:",
			"                id = bisect_right(self._d[left], x)",
			"                ret += self._cum[left][id]",
			"                left += 1",
			"            if right & 1:",
			"                right -= 1",
			"                id = bisect_right(self._d[right], x)",
			"                ret += self._cum[right][id]",
			"            left >>= 1",
			"            right >>= 1",
			"",
			"        return ret",
			"",
			"    def _update_down(self, i: int):",
			"        sz = len(self._d[i])",
			"        if sz == 0: return",
			"        if i < self._size:",
			"            l = MergeSortTree._ceil_pow2(i+1)",
			"            mid = 1<<(self._log-l)",
			"            self._d[i<<1] = self._d[i][:min(mid, sz)]",
			"            if sz > mid: self._d[i<<1|1] = self._d[i][mid:]",
			"        self._d[i].sort()",
			"        self._cum[i] = [0]",
			"        for j in range(sz):",
			"            self._cum[i].append(self._cum[i][-1]+self._d[i][j])",
			""
		]
	},
	"Binary Trie": {
		"prefix": "binary trie",
		"body": [
			"class BinaryTrie:",
			"    NODES = 16777216 # 480MB memory",
			"",
			"    def __init__(self, MAX_LOG: int = 30):",
			"        self._nxt = [0]*(2*BinaryTrie.NODES)",
			"        self._size = [0]*BinaryTrie.NODES",
			"",
			"        self._pid = 0",
			"        self._root = 0",
			"        self.MAX_LOG = MAX_LOG",
			"    ",
			"    def _next_pid(self):",
			"        self._pid += 1",
			"        return self._pid",
			"",
			"    def add(self, x: int) -> None:",
			"        v = self._root",
			"        stack = [v]",
			"        for i in range(self.MAX_LOG - 1, -1, -1):",
			"            c = (x >> i) & 1",
			"            if self._nxt[2*v+c] == 0:",
			"                self._nxt[2*v+c] = self._next_pid()",
			"            v = self._nxt[2*v+c]",
			"            stack.append(v)",
			"        if self._size[v]:",
			"            return",
			"        for v in stack:",
			"            self._size[v] += 1",
			"",
			"    def discard(self, x: int) -> None:",
			"        v = self._root",
			"        stack = [v]",
			"        for i in range(self.MAX_LOG - 1, -1, -1):",
			"            c = (x >> i) & 1",
			"            if self._nxt[2*v+c] == 0:",
			"                return",
			"            v = self._nxt[2*v+c]",
			"            stack.append(v)",
			"        while len(stack) > 1:",
			"            if self._size[stack[-1]] > 1:",
			"                break",
			"            v = stack.pop()",
			"            nv = stack[-1]",
			"            if self._nxt[2*nv] == v:",
			"                self._nxt[2*nv] = 0",
			"            else:",
			"                self._nxt[2*nv+1] = 0",
			"        for v in stack:",
			"            self._size[v] -= 1",
			"        ",
			"    def __contain__(self, x: int) -> bool:",
			"        v = self._root",
			"        for i in range(self.MAX_LOG - 1, -1, -1):",
			"            c = (x >> i) & 1",
			"            if self._nxt[2*v+c] == 0:",
			"                return False",
			"            v = self._nxt[2*v+c]",
			"        return True",
			"    ",
			"    def max_element(self, xor: int = 0) -> int:",
			"        v = self._root",
			"        if self._size[v] == 0:",
			"            return -1",
			"        for i in range(self.MAX_LOG - 1, -1, -1):",
			"            if self._nxt[2*v+1] == 0:",
			"                v = self._nxt[2*v]",
			"                continue",
			"            if self._nxt[v][0] == 0:",
			"                v = self._nxt[2*v+1]",
			"                res += 1 << i",
			"                continue",
			"            if (xor >> i) & 1:",
			"                v = self._nxt[2*v]",
			"            else:",
			"                v = self._nxt[2*v+1]",
			"                res += 1 << i",
			"        return res ^ xor",
			"    ",
			"    def min_element(self, xor: int = 0) -> int:",
			"        v = self._root",
			"        if self._size[v] == 0:",
			"            return -1",
			"        res = 0",
			"        for i in range(self.MAX_LOG - 1, -1, -1):",
			"            if self._nxt[2*v] == 0:",
			"                v = self._nxt[2*v+1]",
			"                res += 1 << i",
			"                continue",
			"            if self._nxt[2*v+1] == 0:",
			"                v = self._nxt[2*v]",
			"                continue",
			"            if (xor >> i) & 1:",
			"                v = self._nxt[2*v+1]",
			"                res += 1 << i",
			"            else:",
			"                v = self._nxt[2*v]",
			"        return res ^ xor",
			"    ",
			"    def get_kth(self, k: int, xor: int = 0) -> int:",
			"        v = self._root",
			"        if self._size[v] <= k:",
			"            return -1",
			"        res = 0",
			"        for i in range(self.MAX_LOG - 1, -1, -1):",
			"            if self._nxt[2*v] == 0:",
			"                v = self._nxt[2*v+1]",
			"                res += 1 << i",
			"                continue",
			"            if self._nxt[2*v+1] == 0:",
			"                v = self._nxt[2*v]",
			"                continue",
			"            if (xor >> i) & 1:",
			"                if self._size[self._nxt[2*v+1]] <= k:",
			"                    k -= self._size[self._nxt[2*v+1]]",
			"                    v = self._nxt[2*v]",
			"                    res += 1 << i",
			"                else:",
			"                    v = self._nxt[2*v+1]",
			"            else:",
			"                if self._size[self._nxt[2*v]] <= k:",
			"                    k -= self._size[self._nxt[2*v]]",
			"                    v = self._nxt[2*v+1]",
			"                    res += 1 << i",
			"                else:",
			"                    v = self._nxt[2*v]",
			"        return res ^ xor"
		]
	},
	"LCA": {
		"prefix": "lca",
		"body": [
			"# https://judge.yosupo.jp/submission/270871",
			"class RangeQuery:",
			"    def __init__(self, data, func=min):",
			"        self.func = func",
			"        self._data = _data = [list(data)]",
			"        i, n = 1, len(_data[0])",
			"        while 2 * i <= n:",
			"            prev = _data[-1]",
			"            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])",
			"            i <<= 1",
			"",
			"    def query(self, begin, end):",
			"        depth = (end - begin).bit_length() - 1",
			"        return self.func(self._data[depth][begin], self._data[depth][end - (1 << depth)])",
			"",
			"class LCA:",
			"    # graph: p_i -> i",
			"    def __init__(self, root, graph):",
			"        self.time = [-1] * len(graph)",
			"        self.path = [-1] * len(graph)",
			"        P = [-1] * len(graph)",
			"        t = -1",
			"        dfs = [root]",
			"        while dfs:",
			"            node = dfs.pop()",
			"            self.path[t] = P[node]",
			"            self.time[node] = t = t + 1",
			"            for nei in graph[node]:",
			"                if self.time[nei] == -1:",
			"                    P[nei] = node",
			"                    dfs.append(nei)",
			"        self.rmq = RangeQuery(self.time[node] for node in self.path)",
			"",
			"    def __call__(self, a, b):",
			"        if a == b:",
			"            return a",
			"        a = self.time[a]",
			"        b = self.time[b]",
			"        if a > b:",
			"            a, b = b, a",
			"        return self.path[self.rmq.query(a, b)]"
		]
	},
	"Convolution998": {
		"prefix": "convolution",
		"body": [
			"# https://judge.yosupo.jp/submission/55648",
			"# AtCoder Libary v1.4 を python に移植したもの",
			"# https://github.com/atcoder/ac-library/blob/master/atcoder/convolution.hpp",
			"",
			"MOD = 998244353",
			"IMAG = 911660635",
			"IIMAG = 86583718",
			"rate2 = (0, 911660635, 509520358, 369330050, 332049552, 983190778, 123842337, 238493703, 975955924, 603855026, 856644456, 131300601, 842657263, 730768835, 942482514, 806263778, 151565301, 510815449, 503497456, 743006876, 741047443, 56250497, 867605899, 0)",
			"irate2 = (0, 86583718, 372528824, 373294451, 645684063, 112220581, 692852209, 155456985, 797128860, 90816748, 860285882, 927414960, 354738543, 109331171, 293255632, 535113200, 308540755, 121186627, 608385704, 438932459, 359477183, 824071951, 103369235, 0)",
			"rate3 = (0, 372528824, 337190230, 454590761, 816400692, 578227951, 180142363, 83780245, 6597683, 70046822, 623238099, 183021267, 402682409, 631680428, 344509872, 689220186, 365017329, 774342554, 729444058, 102986190, 128751033, 395565204, 0)",
			"irate3 = (0, 509520358, 929031873, 170256584, 839780419, 282974284, 395914482, 444904435, 72135471, 638914820, 66769500, 771127074, 985925487, 262319669, 262341272, 625870173, 768022760, 859816005, 914661783, 430819711, 272774365, 530924681, 0)",
			"",
			"def butterfly(a):",
			"    n = len(a)",
			"    h = (n - 1).bit_length()",
			"    le = 0",
			"    while le < h:",
			"        if h - le == 1:",
			"            p = 1 << (h - le - 1)",
			"            rot = 1",
			"            for s in range(1 << le):",
			"                offset = s << (h - le)",
			"                for i in range(p):",
			"                    l = a[i + offset]",
			"                    r = a[i + offset + p] * rot",
			"                    a[i + offset] = (l + r) % MOD",
			"                    a[i + offset + p] = (l - r) % MOD",
			"                rot *= rate2[(~s & -~s).bit_length()]",
			"                rot %= MOD",
			"            le += 1",
			"        else:",
			"            p = 1 << (h - le - 2)",
			"            rot = 1",
			"            for s in range(1 << le):",
			"                rot2 = rot * rot % MOD",
			"                rot3 = rot2 * rot % MOD",
			"                offset = s << (h - le)",
			"                for i in range(p):",
			"                    a0 = a[i + offset]",
			"                    a1 = a[i + offset + p] * rot",
			"                    a2 = a[i + offset + p * 2] * rot2",
			"                    a3 = a[i + offset + p * 3] * rot3",
			"                    a1na3imag = (a1 - a3) % MOD * IMAG",
			"                    a[i + offset] = (a0 + a2 + a1 + a3) % MOD",
			"                    a[i + offset + p] = (a0 + a2 - a1 - a3) % MOD",
			"                    a[i + offset + p * 2] = (a0 - a2 + a1na3imag) % MOD",
			"                    a[i + offset + p * 3] = (a0 - a2 - a1na3imag) % MOD",
			"                rot *= rate3[(~s & -~s).bit_length()]",
			"                rot %= MOD",
			"            le += 2",
			"",
			"def butterfly_inv(a):",
			"    n = len(a)",
			"    h = (n - 1).bit_length()",
			"    le = h",
			"    while le:",
			"        if le == 1:",
			"            p = 1 << (h - le)",
			"            irot = 1",
			"            for s in range(1 << (le - 1)):",
			"                offset = s << (h - le + 1)",
			"                for i in range(p):",
			"                    l = a[i + offset]",
			"                    r = a[i + offset + p]",
			"                    a[i + offset] = (l + r) % MOD",
			"                    a[i + offset + p] = (l - r) * irot % MOD",
			"                irot *= irate2[(~s & -~s).bit_length()]",
			"                irot %= MOD",
			"            le -= 1",
			"        else:",
			"            p = 1 << (h - le)",
			"            irot = 1",
			"            for s in range(1 << (le - 2)):",
			"                irot2 = irot * irot % MOD",
			"                irot3 = irot2 * irot % MOD",
			"                offset = s << (h - le + 2)",
			"                for i in range(p):",
			"                    a0 = a[i + offset]",
			"                    a1 = a[i + offset + p]",
			"                    a2 = a[i + offset + p * 2]",
			"                    a3 = a[i + offset + p * 3]",
			"                    a2na3iimag = (a2 - a3) * IIMAG % MOD",
			"                    a[i + offset] = (a0 + a1 + a2 + a3) % MOD",
			"                    a[i + offset + p] = (a0 - a1 + a2na3iimag) * irot % MOD",
			"                    a[i + offset + p * 2] = (a0 + a1 - a2 - a3) * irot2 % MOD",
			"                    a[i + offset + p * 3] = (a0 - a1 - a2na3iimag) * irot3 % MOD",
			"                irot *= irate3[(~s & -~s).bit_length()]",
			"                irot %= MOD",
			"            le -= 2",
			"",
			"def multiply(s, t):",
			"    n = len(s)",
			"    m = len(t)",
			"    if min(n, m) <= 60:",
			"        a = [0] * (n + m - 1)",
			"        for i in range(n):",
			"            if i % 8 == 0:        ",
			"                for j in range(m):",
			"                    a[i + j] += s[i] * t[j]",
			"                    a[i + j] %= MOD",
			"            else:",
			"                for j in range(m):",
			"                    a[i + j] += s[i] * t[j]",
			"        return [x % MOD for x in a]",
			"    a = s[::]",
			"    b = t[::]",
			"    z = 1 << (n + m - 2).bit_length()",
			"    a += [0] * (z - n)",
			"    b += [0] * (z - m)",
			"    butterfly(a)",
			"    butterfly(b)",
			"    for i in range(z):",
			"        a[i] *= b[i]",
			"        a[i] %= MOD",
			"    butterfly_inv(a)",
			"    a = a[:n + m - 1]",
			"    iz = pow(z, MOD - 2, MOD)",
			"    return [v * iz % MOD for v in a]"
		]	
	}
}