# 文字列検索
## Rolling Hash
* 文字列をハッシュ化してハッシュを比較する
* １対１の検索ができ、検索位置をランダムにとることが可能。
* データをセグ木で持つことによって文字列の変更クエリにも対応できる。

### 計算量
#### 前計算: $O(|S|)$
#### 検索クエリ: $O(1)$
$S[l_s, r_s),T[l_t, r_s)(r_s-l_s = r_t-l_t)$のハッシュをそれぞれ取得して比較する。

### 計算量（文字列変更がある場合）
#### 前計算: $O(|S|)$
#### 文字列の一点更新: $O(log|S|)$
一回目の更新クエリの時に内部のデータの持ち方をセグ木に変更するために$O(|S|log|S|)$の計算が行われる。
#### 検索クエリ: $O(log|S|)$

### サンプルコード
```python
# ↑にrolling hashの定義
# ABC331F

N, Q = map(int, input().split())
S = input()
L = RollingHash(S)
R = RollingHash(S, True)

for _ in range(Q):
    t, a, b = input().split()
    if t == "1":
        x, c = int(a)-1, b
        L.set(x, c) # 一点更新
        R.set(x, c) # 一点更新
    else:
        l, r = int(a)-1, int(b)
        m = (r-l+1)//2
        if L.value(l, l+m) == R.value(r-m, r):
            print(Yes)
        else:
            print(No)
```

### ライブラリのスニペット
`rollinghash`
#### 構築 $O(|S|)$
```python
S = "abcba"
# ローリングハッシュを構築
R = RollingHash(S)

# reverseフラグをTrueにすると文字列を反転して構築
# 要素へのアクセスは元の文字列の添え字でアクセスできる
R_reversed = RollingHash(S, True)
```
#### ハッシュ取得 $O(1)$
```python
hash = R.value(l, r) # S[l, r)のハッシュを取得する
hash_reversed = R_reversed.value(l, r) # S[l, r)を反転した文字列のハッシュを取得する

assert(R.value(0, 3) == R_reversed.value(2, 5)) # S := "abcba"
```

#### 文字列変更 $O(log|S|)$
```python
R.set(x, c) # S[x]をcに変更する
```
※変更クエリが一度でも行われると内部のデータの持ち方がセグ木に変更され、ハッシュ取得クエリの計算量が$O(1)$から$O(log|S|)$になる

>[!WARNING]
文字列から数字への変換はデフォルトでは英小文字として処理している。
大文字の場合や、01列の場合は`RollingHash._to_num`関数の中身を変更して対応する。

## Z-algorithm


## Aho-Corasick

